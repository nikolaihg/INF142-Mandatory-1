\section{Oppgaver}\label{oppgaver}

\subsection{a)
Applikasjonsnivåprotokoll}\label{a-applikasjonsnivuxe5protokoll}

\subsubsection{Format}\label{format}

Å bruke ett json format virker som et bra utgangspunkt, siden da kan man
sende meldinger i json, så lagre disse i en json-liste. Dette gjør også
at man kan bruke ett python dictionary som ``database''.

Med oppbygning slik:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{database }\OperatorTok{=}\NormalTok{ \{}
    \DecValTok{100}\NormalTok{ : \{}
    \StringTok{"tittel"}\NormalTok{: }\StringTok{"Hva skal jeg ha til middag?"}\NormalTok{,}
    \StringTok{"alternativ"}\NormalTok{: \{}
        \StringTok{"Pølse"}\NormalTok{: }\DecValTok{0}\NormalTok{, }\StringTok{"Hamburger"}\NormalTok{: }\DecValTok{0}\NormalTok{, }\StringTok{"PIzza"}\NormalTok{: }\DecValTok{0}
\NormalTok{        \}}
\NormalTok{    \}  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(Først kommer problemID, så all tilhørende informasjon om selve
problemet.)

\subsubsection{Meldinger}\label{meldinger}

\paragraph{\texorpdfstring{\textbf{Post problem: (valg 1. i
\texttt{client.py})}}{Post problem: (valg 1. i client.py)}}\label{post-problem-valg-1.-i-client.py}

Klient oppgir tittel og alternativ, får tilbake problemID som ble
generet da tjeneren ligger til problemet i databasen. - Klient
\(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "kommando"\ :\ 1,\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1",\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2",\ \ \ \ \ \ \ \ \ "(...)"{]}}
- Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ \ "melding"\ :\ "problem\ lagt\ til\ i\ database",\ \ \ \ \ "problemID"\ :\ problemID,}
\#\#\#\# \textbf{Spør etter problem: (valg 2. i \texttt{client.py}}
Klient velger valg nr. 2 i prompt, server returnerer alle problemer som
er lagret i databasen. - Klient \(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "kommando"\ :\ 2} - Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ \{\ \ \ \ \ \ \ \ \ 100\ :\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ "tittel":\ "Hva\ skal\ jeg\ ha\ til\ middag?",\ \ \ \ \ \ \ \ \ \ \ \ \ "alternativ":\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "Pølse":\ 0,\ "Hamburger":\ 0,\ "PIzza":\ 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ 99\ :\ \{\ (...)\ \},\ \ \ \ \ \ \ \ \ 88\ :\ \{\ (...)\ \},\ \ \ \ \ \}}
\#\#\#\# \textbf{Vis en problemformulering: (valg 3. i
\texttt{client.py}} Klient velger valg 3 i prompt, så oppgir problemID,
server returnerer samsvarende problem (hvis det finnes). - Klient
\(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "kommando"\ :\ 3,\ \ \ \ \ "problemID"\ :\ problemID,}
- Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1",\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2",\ \ \ \ \ \ \ \ \ "(...)"{]}}
Hvis ikke så returnerer server:
\texttt{json\ \ \ \ \ "melding"\ :\ "Ønsket\ problem\ finnes\ ikke"}
\#\#\#\# \textbf{Vis alternativer: (valg 4. i \texttt{client.py}} Klient
gir problemID, så returnerer server alternativene for gitt problem. -
Klient \(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "kommando"\ :\ 4,\ \ \ \ \ "problemID"\ :\ problemID}
- Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1",\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2",\ \ \ \ \ \ \ \ \ "(...)"{]}}
\#\#\#\# \textbf{Stem på alternativ: (valg 5. i \texttt{client.py}}
Klient oppgir problemID, så oppgir tjener tittel+alternativ (via samme
funksjon som i valg 3.), så stemmer klient på ønsket alternativ.
Deretter så bekrefter tjener at den har mottatt stemmen. - Klient
\(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "kommando"\ :\ 5,\ \ \ \ \ "problemID"\ :\ problemID,}
- Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1",\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2",\ \ \ \ \ \ \ \ \ "(...)"{]}}
- Klient \(\rightarrow\) Server:
\texttt{json\ \ \ \ \ "stemme"\ :\ STEMME\ (tall\ =\ 1..n)} - Klient
\(\leftarrow\) Server:
\texttt{json\ \ \ \ \ "melding"\ :\ "stemme\ mottatt",\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1",\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2",\ \ \ \ \ \ \ \ \ "(...)"{]}}
\#\#\#\# \textbf{Vis stemmer på et problem: (valg 6. i
\texttt{client.py}} Klient oppgir valg 6 i prompt, så problemID. Tjener
svarer med tittel på problemet og antall stemmer. - Klient
\(\rightarrow\) Server:
\texttt{json\ \ \ \ \ \ "kommando"\ :\ 6,\ \ \ \ \ "problemID"\ :\ problemID}
- Klient \(\leftarrow\) Server:
\texttt{json\ \ \ \ \ "tittel"\ :\ "tittel\ tekst",\ \ \ \ \ "alternativ"\ :\ {[}\ \ \ \ \ \ \ \ \ "Alternativ\ 1"\ :\ antall\_stemmer\ (1..n),\ \ \ \ \ \ \ \ \ \ "Alternativ\ 2"\ antall\_stemmer\ (1..n),\ \ \ \ \ \ \ \ \ "(...)"{]}}

\subsection{b) Tilstandsløs vs tilstandsfull og TCP vs
UDP}\label{b-tilstandsluxf8s-vs-tilstandsfull-og-tcp-vs-udp}

\subsubsection{Tilstandsløs vs
tilstandsfull}\label{tilstandsluxf8s-vs-tilstandsfull}

Applikasjonsprotokollen er tilstandsløs, da alle meldinger inneholder
all informasjonen som trengs. \#\#\# TCP vs UDP TCP er best egnet da vi
trenger pålitelig overføring av data, siden det er viktig at stemmer
blir registrert riktig

\subsection{c) Implementering klient-server-applikasjon NVDA i
python}\label{c-implementering-klient-server-applikasjon-nvda-i-python}

Se \texttt{server.py} og \texttt{client.py}
